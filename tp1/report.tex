%% A alterar: <--ALTERAR-->

\documentclass[11pt,a4paper]{report}
\title{}
\author{}

%% Package ---------------------------------------------------------------------{{{1
\usepackage{multicol}           % 
\usepackage{longtable}          % Tables continue in the next page
\usepackage{listings}           % Programming syntax
\usepackage{color}

%% Package settings ------------------------------------------------------------{{{1
\setlength{\columnsep}{3cm}                         % {multicol} - Column spacement
\definecolor{engineering}{rgb}{0.549,0.176,0.098}   % {color}
\definecolor{cloudwhite}{cmyk}{0,0,0,0.025}         % {color}
\lstdefinestyle{ccode}                              % {listings} - C syntax
{
    keepspaces=true,
    numbersep=5pt,

    basicstyle=\footnotesize\ttfamily,
    keywordstyle=\bfseries,
    numbers=left,                                   % where to put the line-numbers
    numberstyle=\scriptsize\texttt,                 % the size of the fonts that are used for the line-numbers
    stepnumber=1,                                   % the step between two line-numbers. If it's 1 each line will be numbered
    numbersep=8pt,                                  % how far the line-numbers are from the code
    frame=tb,
    float=htb,
    aboveskip=8mm,
    belowskip=4mm,
    backgroundcolor=\color{cloudwhite},             
    showspaces=false,                               % show spaces adding particular underscores
    showstringspaces=false,                         % underline spaces within strings
    showtabs=false,                                 % show tabs within strings adding particular underscores
    tabsize=2,                                      % sets default tabsize to 2 spaces
    captionpos=b,                                   % sets the caption-position to bottom
    breaklines=true,                                % sets automatic line breaking
    breakatwhitespace=false,                        % sets if automatic breaks should only happen at whitespace
    escapeinside={\%*}{*)},                         % if you want to add a comment within your code
    morekeywords={*,var,template,new}               % if you want to add more keywords to the set
}
\fancyhf{}                                          % {fancyhdr} clear off all default fancyhdr headers and footers
\lfoot{\small{\emph{\projtitle, \projsubtitle}}}    % {fancyhdr}
\rfoot{\small{\thepage\ / \pageref{LastPage}}}      % {fancyhdr}
\pagestyle{fancy}                                   % {fancyhdr} apply the fancy header style
\renewcommand{\headrulewidth}{0.0pt}                % {fancyhdr} no head rule
\renewcommand{\footrulewidth}{0.4pt}                % {fancyhdr}
\hypersetup{                                        % {hyperref}
    plainpages=false,
    pdfpagelayout=SinglePage,
    bookmarksopen=false,
    bookmarksnumbered=true,
    breaklinks=true,
    linktocpage,
    colorlinks=true,
    linkcolor=engineering,
    urlcolor=engineering,
    filecolor=engineering,
    citecolor=engineering,
    allcolors=engineering
}

%\usepackage{comment}               % Permite criar um segmento de comentários (/begin{comment} [...] /end{comment})
%\usepackage{xcolor}                % Colorir texto (esta versão é mais flexível do que a {color})
%\usepackage{subcaption}            % Subcaptions para figuras
%\usepackage{fullpage}              % Utilizar página inteira

%% Document start --------------------------------------------------------------{{{1
\begin{document}
    \section{Código}
        \begin{center}
            \begin{longtable}{ l l l }
                %% [ inserir texto fora da coluna ]
                vector_stat_.c & utilities.c & utilities.h
                \lstset{style=ccode} \lstinputlisting[language=C, caption=]{vector_stat_proc.c} & \lstset{style=ccode} \lstinputlisting[language=C, caption=]{utilities.c} & \lstset{style=ccode} \lstinputlisting[language=C, caption=]{utilities.h}
            \end{longtable}
        \end{center}

    \section{Estratégias adotadas}
        O objetivo do enunciado é expandir a função "int vector_get_in_range();" de forma a tirar proveito da criação de processos. Assim, optou-se por desenvolver toda a
        lógica de processos dentro da função, tornando-a genérica.

        A assinatura da função requer dois vetores. O vetor principal onde será preenchido com números aleatórios e um sub-vetor com os valores compreendidos num
        determinado intervalo também passados como argumentos. É também enviado o número de processos desejados para auxiliar o processamento dos dados.

        Todas as funções foram inseridas no ficheiro "utilities.c" de maneira que o código fique mais organizado.

        Na função "int vector_get_in_range();" procedeu-se ao cálculo da quantidade de elementos a atribuir por processo.
        O foco principal foi atribuir os elementos o
        mais equilibradamente possível, não havendo processos com valores exagerados de posições a processar. No caso da divisão não ser um número inteiro, o número de
        elementos é atribuído de maneira sensata, preenchendo de modo equitativo até não sobrar resíduo da divisão. Para alcançar este objetivo, criaram-se duas
        variáveis auxiliares: "addLeftover" e "moveLeftover" para avançar o ponteiro do vetor.
        O vetor "svCount" com apenas uma posição permite guardar o valor contado de números válidos inseridos no subvetor. Posteriormente enviado pelo pipe.

        Para não estar a passar um subvetor de tamanho gigante para os filhos, realizou-se uma re-alocagem com o tamanho do valor da variável "slices", aqui não se
        contabilizou o resto da divisão, mais uma posição não faz diferença.

        É criado um vetor dinâmico de "pipes" para que cada filho possa ter o seu. É também guardado o endereço original dado que o vetor original será
        reposicionado consoante o filho.

        Após a efetuação do fork os processos filhos fecham o canal de leitura do pipe e os pais o de escrita.
        O filho verifica se existem valores compreendidos nos limites pedidos e escreve-os no sub-vetor. Primeiro escreve o número de elementos contados no pipe, de
        seguida escreve o sub-vetor. O intuito passa pelo pai poder escrever sempre os valores necessários no sub-vetor e avançar o mesmo número de posições para
        escrever os próximos. E também guardar esse valor de forma a devolvê-lo à função principal. No final, libertam-se os vetores dinâmico.
        Aqui foi necessário devolver um valor que não zero para que quando chegasse ao "main", o programa não continuasse para fora.

        O pai move o vetor dos elementos para a frente consoante o valor em "slices" e do resto da divisão assim como o pipe.
\end{document}


/*
 * int v[]          - vetor a analisar
 * int v_sz         - tamanho do vetor
 * int sv[]         - vetor onde será guardado o subvetor
 *
 * int n_processes  - número de processos a utilizar
 * A função devolve o número de elementos colocados no subvetor sv ou um valor negativo em caso de erro.
 */
int vector_get_in_range(int v[], int v_sz, int sv[], int min, int max, int n_processes)
{
    /*
     * 6 elementos, 4 processos -> 2 blocos por filho
     * 6 fatias, 4 filhos -> 2 fatias para cada
     * 6 fatias, 5 filhos -> 1 fatia para cada, 1 último para um dos filhos
     */
    int numeroElementosPorFilho = v_sz / n_processes;
    // TODO: Se for ímpar adicionar +1 elemento
    int indexSubvetorInicial=0;
    int indexSubvetorFinal=numeroElementosPorFilho;

    for(int iterador = 0; iterador < n_processes ; iterador++)
    {
        indexSubvetorInicial = indexSubvetorFinal + 1;
        indexSubvetorFinal += numeroElementosPorFilho;

        if(iterador == n_processes)
        {
            if(v_sz % n_processes != 0)
            {
                numeroElementosPorFilho++;
            }
        }

        pid_t ramal=fork();
        if(ramal < FILHO)
        {
            // Falha na criação do ramal
            perror("Erro na criação do processo filho.");
            return -1;
        }
        else if(ramal == FILHO)
        {
            return processoFilho(); //TODO
        }
    }





    long count = 0;
    for (long i = 0; i < v_sz; i++)
    {
        if (v[i] >= min && v[i] <= max)
        {
            sv[count++] = v[i];
        }
    }        
    return count;
}

// Funções do ApoioTP1
/*
 * Generates a random number between min and max.
 * The number sequence generated by the fuction rand is always the 
 * same because it uses the defaulta seed 0.
 */
int get_random(int min, int max) 
{
    return rand() % (max - min + 1) + min;
}

/**
 * Starts the vector with random values belonging to the interval [min..max]
 */
void vector_init_rand(int v[], long dim, int min, int max)
{
    for (long i = 0; i < dim; i++) {
        v[i] = get_random(min, max);
    }
}

// SEQUENTIAL!!!!
/**
 * Gets the subvector of values in the range [min..max]
 * 
 * returns the number of values store in subvector sv 
 */
//int vector_get_in_range (int v[], int v_sz, int sv[], int min, int max)
//{
//    long count = 0;
//
//    for (long i = 0; i < v_sz; i++) {
//        if (v[i] >= min && v[i] <= max) {
//            sv[count++] = v[i];
//        }
//    }        
//    return count;
//}
